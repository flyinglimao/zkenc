\section{Proposed Scheme}\label{sec-prop}
\subsection{Extractable Witness Key Encapsulation Mechanisms}
Our strategy is to first construct an extractable WKEM for QAPs and then show how it can be adapted to a full WE scheme. We follow the work of~\textcite{fleischhacker2024extractable} to define the notion of an extractable WKEM relative to an indexed family of NP relations.

\begin{definition}[Indexed Family of NP Relations]
    Let $\mathcal{I} \subseteq \{0, 1\}^*$ be a set. A set $\mathcal{F} = \{ \mathcal{R}_I \}_{I \in \mathcal{I}}$ is a family of NP relations with the index set $\mathcal{I}$ if for all $I \in \mathcal{I}$, $\mathcal{R}_I$ is an NP relation, where $I$ means the index of $\mathcal{R}_I$ and $\mathcal{R}_I$ is the relation identified by $I$, respectively. We denote $\mathcal{L}_I$ as the corresponding NP language.
\end{definition}

A WKEM is similar to a traditional KEM, but uses statement-witness pairs from an NP relation instead of public-secret key pairs.

\begin{definition}[Witness Key Encapsulation Mechanism]
    A WKEM for a key space $\mathcal{K}$ and a family of NP relations $\mathcal{F}$ is a pair of PPT algorithms $\text{WKEM} = (\textbf{Encap}, \textbf{Decap})$ as follows:
\end{definition}
\begin{description}
    \item[$(ct, k) \gets \text{Encap}(I, x)$]: Given an index $I$ and a statement $x$, this algorithm outputs a ciphertext $ct$ and a key $k \in \mathcal{K}$.
    \item[$k \gets \text{Decap}(I, w, ct)$]: Given an index $I$, witness $w$, and a ciphertext $ct$, this algorithm outputs a key $k \in \mathcal{K}$.
\end{description}

The security properties of a WKEM are correctness and extractability. Correctness ensures that a valid witness allows for decapsulation of the key. Extractability ensures that any adversary who can distinguish a real key from a random one can be used to construct an extractor that finds a valid witness for the statement.

\begin{definition}[Correctness of WKEM]\label{def-WKEMcorr}
    A tuple of algorithms $(\text{Encap}, \text{Decap})$ is a correct WKEM for a family of NP relations $\mathcal{F}$, if for any $\lambda \in \mathbb{N}$, any $\mathcal{R}_I \in \mathcal{F}$, any $(x, w) \in \mathcal{R}_I$, and any $(ct, k) \gets \text{Encap}(I, x)$, it holds that $\text{Decap}(I, w, ct) = k$.
\end{definition}

\begin{definition}[Extractability of WKEM]\label{def-WKEMextract}
    A tuple of algorithms $(\text{Encap}, \text{Decap})$ is an extractable WKEM for a family of NP relations $\mathcal{F}$, if there exists a non-uniform PPT algorithm $\text{Ext}$ such that for any non-uniform stateful PPT adversary $\mathcal{A}$ and any relation $\mathcal{R}_I \in \mathcal{F}$ for which
    \begin{equation*}
        \text{Pr}[\text{Expt}^\text{CPA}_{\text{WKEM},\mathcal{A}}(1^\lambda, I) = 1] \geq \frac{1}{2} + \epsilon(\lambda)
    \end{equation*}
    for some non-negligible function $\epsilon(\lambda)$, it holds that
    \begin{equation*}
        \text{Pr}\left[
            (x, w) \in \mathcal{R}_I : 
            \begin{array}{r}
                x \gets \mathcal{A}(1^\lambda, I) \\
                w \gets \text{Ext}^{\mathcal{A}(\cdot, \cdot)}(I, x)
            \end{array}
        \right] \geq \delta(\lambda),
    \end{equation*} 
    for some non-negligible function $\delta(\lambda)$. The experiment $\text{Expt}^\text{CPA}_{\text{WKEM},\mathcal{A}}(1^\lambda, I)$ is defined below.
\end{definition}

\newsavebox{\returnOfExptWKEMCPA}
\setbox\returnOfExptWKEMCPA\hbox{
    $\begin{cases}
        1 & \text{if } b' = b \\
        0 & \text{otherwise}
    \end{cases}$
}
\procedureblock{$\text{Expt}^\text{CPA}_{\text{WKEM},\mathcal{A}}(1^\lambda, I)$}{
    x \leftarrow \mathcal{A}(1^\lambda, I) \\
    b \sample \{0, 1\} \\
    (ct, k_0) \leftarrow \text{Encap}(I, x) \\
    k_1 \sample \mathcal{K} \\
    b' \leftarrow \mathcal{A}(ct, k_b) \\
    \pcreturn\usebox\returnOfExptWKEMCPA
}

\subsection{Construction of the WKEM for QAPs}
We construct an extractable WKEM for a family of relations described by QAPs. Let $\mathcal{Q}$ be the set of valid QAPs generated by a relation generator. We define the family of NP relation of valid QAPs as:
\begin{equation*}
    \mathcal{F}_\text{QAP} \coloneq \{ \mathcal{R}_Q \}_{Q \in \mathcal{Q}},
\end{equation*}
where
\begin{equation*}
    \mathcal{R}_Q = \left\{
        (\{a_i\}_{i=0}^\ell, \{a_i\}_{i=\ell+1}^m) \middle\vert
        \begin{aligned}
            &\text{The coefficients satisfy the QAP equation:} \\
            &\sum_{i=0}^m a_i u_i(X) \cdot \sum_{i=0}^m a_i v_i(X) \equiv \sum_{i=0}^m a_i w_i(X) \bmod t(X)
        \end{aligned}
    \right\}.
\end{equation*}
Here, the statement is the set of public inputs $\left\{a_i\right\}_{i=0}^\ell$, and the witness is the set of private inputs $\left\{a_i\right\}_{i=\ell+1}^m$. For notational convenience, we define: $\phi_i(x) \coloneq r\beta u_i(x) + r\alpha v_i(x) + r^2w_i(x)$, where $r$ is a fresh randomness sampled in the Encap$^H$ procedure. The construction uses a hash function $H:\mathbb{G}_T\to\mathcal{K}$ and the algorithms are as follows:


\newsavebox{\crs}
\setbox\crs\hbox{$
    \sigma \coloneq \left\{
        \begin{array}{l}
            [\alpha]_1, [\beta]_2, [\delta]_2 \\
            \left\{ [ru_i(x)]_1 \right\} ^m_{i=0}\\
            \left\{ [rv_i(x)]_2 \right\} ^m_{i=0} \\
            \left\{ [\frac{\phi_i(x)}{\delta}]_1 \right\} ^m_{i=\ell+1} \\
            \left\{ [\frac{r^2 x^i t(x)}{\delta}]_1 \right\} ^{n-2}_{i=0} \\
        \end{array}
    \right\}
$}
\begin{pchstack}[center]
    \procedureblock{$\text{Encap}^H(
        Q,
        \{a_i\}_{i=0}^\ell)
    $}{
        \alpha,\beta,\delta,r,x \sample \mathbb{Z}_p^* \\
        \usebox\crs \\
        s \coloneq [\alpha]_1 \cdot [\beta]_2 + \sum^\ell_{i=0} a_i[\phi_i(x)]_1 \cdot [1]_2 \quad\quad\\
        k \leftarrow H(s) \\
        ct \coloneq (\sigma, \{a_i\}_{i=0}^\ell) \\
        \pcreturn (ct, k)
    }
    \procedureblock[bodylinesep=0.4\baselineskip]{$\text{Decap}^H(
        Q,
        \{a_i\}_{i=\ell+1}^m,
        (\sigma, \{a_i\}_{i=0}^\ell)
    )$}{
        A \coloneq [\alpha]_1 + \sum^{m}_{i=0}a_i [ru_i(x)]_1 \\
        B \coloneq [\beta]_2 + \sum^{m}_{i=0}a_i [rv_i(x)]_2 \\ 
        C \coloneq \sum^{m}_{i=\ell+1}a_i[\frac{\phi_i(x)}{\delta}]_1 + [\frac{r^2h(x)t(x)}{\delta}]_1\\ 
        s \coloneq A \cdot B - C \cdot [\delta]_2 \\
        k \leftarrow H(s) \\
        \pcreturn k
    }
\end{pchstack}


In our construction, the QAP satisfies the constraint $a_0=1$, and contains some degree $n - 2$ quotient polynomial $h(X)$, where $n$ is the degree of $t(X)$ which follows Groth16 convention. The intuition behind this construction is as follows. The encryptor provides $\sigma$ to enable the decryptor to compute the target value $s$. However, to compute $s$ correctly, the decryptor requires access to the terms $\{[r^2w_i(x)]_1\}_{i=0}^\ell$. Since the randomness $r$ is protected by the discrete logarithm assumption and cannot be extracted from the other provided elements, the decryptor cannot directly compute these terms. Instead, the decryptor must leverage the QAP relation itself: by using both the public statement $\{a_i\}_{i=0}^\ell$ and their private witness $\{a_i\}_{i=\ell+1}^m$, they can compute the values $A$, $B$, and $C$ such that $s = A \cdot B - C \cdot [\delta]_2$. The computation completes successfully only when the QAP condition holds on the statement-witness pair, thereby enforcing access control at the level of arithmetic relations.

\subsection{From WKEM to Witness Encryption}
Following \textcite{fleischhacker2024extractable}, the extractable WKEM we just constructed can be generically composed with a symmetric encryption scheme to create a full extractable witness encryption scheme.

\begin{definition}[Witness Encryption Scheme]
    A WE scheme for a message space $\mathcal{M}$ and a family of NP relations $\mathcal{F}$ is a pair of PPT algorithms $\text{WE} = (\text{Enc}, \text{Dec})$ as follows:
\end{definition}
\begin{description}
    \item[$ct \gets \text{Enc}(I, x, m)$]: Given an index $I$, a statement $x$, and a message $m \in \mathcal{M}$, this algorithm returns a ciphertext $ct$.
    \item[$m / \perp \gets \text{Dec}(I, w, ct)$]: Given an index $I$, a ciphertext $ct$, and a witness $w$, this algorithm returns a message $m \in \mathcal{M}$ or an error symbol $\perp$.
\end{description}

\begin{definition}[Correctness of WE]\label{def-WEcorr}
    A tuple of algorithms $(\text{Enc}, \text{Dec})$ is a correct WE scheme for a family of NP relations $\mathcal{F}$, if for any $\lambda \in \mathbb{N}$, any $\mathcal{R}_I \in \mathcal{F}$, any $m \in \mathcal{M}$, and any $ct \gets \text{Enc}(I, x, m)$, it holds that $\text{Dec}(I, w, ct) = m$.
\end{definition}

\begin{definition}[Extractability of WE]\label{def-WEextract}
    A tuple of algorithms $(\text{Enc}, \text{Dec})$ is an extractable WE scheme for a family of NP relations $\mathcal{F}$, if there exists a PPT algorithm $\text{Ext}$ such that for any stateful PPT
    adversary $\mathcal{A}$ and any relation $\mathcal{R}_I \in \mathcal{F}$ for which
    \begin{equation*}
        \text{Pr}[\text{Expt}^\text{CPA}_{\text{WE},\mathcal{A}}(1^\lambda, I) = 1] \geq \frac{1}{2} + \epsilon(\lambda)
    \end{equation*}
    for some non-negligible function $\epsilon(\lambda)$, it holds that
    \begin{equation*}
        \text{Pr}\left[
            (x, w) \in \mathcal{R}_I : 
            \begin{array}{r}
                (x, m_0, m_1) \gets \mathcal{A}(1^\lambda, I) \\
                w \gets \text{Ext}^{\mathcal{A}(\cdot, \cdot)}(I, x, m_0, m_1)
            \end{array}
        \right] \geq \delta(\lambda),
    \end{equation*}
    for some non-negligible function $\delta(\lambda)$. The experiment $\text{Expt}^\text{CPA}_{\text{WE},\mathcal{A}}(1^\lambda, I)$ is defined below.
\end{definition}

\procedureblock{$\text{Expt}^\text{CPA}_{\text{WE},\mathcal{A}}(1^\lambda, I)$}{
    (x, m_0, m_1) \leftarrow \mathcal{A}(1^\lambda, I) \\
    b \sample \{0, 1\} \\
    ct \leftarrow \text{Enc}(I, x, m_b) \\
    b' \leftarrow \mathcal{A}(ct) \\
    \pcreturn \usebox\returnOfExptWKEMCPA
}

Let $(\text{Dec}^\text{sym}, \text{Enc}^\text{sym})$ be a one-time symmetric encryption scheme. The WE scheme $\text{WE}$ is constructed as follows:

\begin{pchstack}[center]
    \procedure{$\text{Enc}(I,x,m)$}{
        (ct_1, k) \leftarrow \text{Encap}(I, x) \\
        ct_2 \leftarrow \text{Enc}^\text{sym}(k, m) \\
        \pcreturn (ct_1, ct_2)
    }
    \procedure{$\text{Dec}(I,w,(ct_1, ct_2))$}{
        k \coloneq \text{Decap}(I, w, ct_1) \\
        m \coloneq \text{Dec}^\text{sym}(k, ct_2) \\
        \pcreturn m
    }
\end{pchstack}
